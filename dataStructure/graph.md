# 图
关键字： 最短路径、最小生成树、深度遍历、广度遍历、拓扑排序
图最初来自图论这个由柯尼斯堡问题产生的，最终由欧拉解决，并诞生了图论。
## 定义
图由节点的有穷集合V和边的集合E组成。为了和树进行区别，图结构中节点称为顶点。
## 存储结构
图的存储结构分为两种顺序表和链表，经典的有邻阶矩阵使用矩阵表示两点之间是否连通，
邻阶表，使用链表存储，一个数组表示所有的节点，每个节点指向一个链表，链表内容就是
本节点和其他连通的节点。
## 遍历
图的深度遍历就是使用栈的思想，先访问当前节点，然后让它入栈，接着访问其连接的节点
没有访问过则入栈，否则就换下个节点，还是栈的思想。主要使用递归实现。
图的广度遍历就是使用队列的思想和树的层次遍历是一样的，先访问该节点的所有连接顶点
然后访问的同时进行入队，然后出队继续访问。
主要就是这个思想的转换，因为记住算法总是容易忘记，但是如果把这个思想记录下来再
结合实际情况就可以得到想要的算法，先进先出、先进后出，栈 和 队列的思想，就这两个
但是在不同的场景中其实践方式不一样，达到的效果也不一样，但是其理论是一样的。
## 最小生成树
最小生成树是给无向树准备的，只要生成了最小生成树，则肯定有最短路径，因为是无向图。
最小生成树算法可以分为两个方面，一个是以顶点为核心去生成，一个是以边和为核心进行
生成，分别适合边比较多的稠密图（边比较多），和顶点比较多的稀疏图(边比较少)。
### 普利姆算法(以顶点为核心)
从图中任意选择一个节点作为一棵树，从与这棵树相连的边中选择一条最短的边，并入该树种
种，重复以上过程，直到所有的顶点都并入树种。
### 克鲁斯卡尔算法(以边为核心)
每次找出候选边中权值最小的边，将边并入生成树种，重复此过程直到所有的边都被检测完为止，
## 最短路径
### 地杰斯特拉算法（一个点到其他所有节点）
设有两个集合S、T,集合S中存放已找到的最短路径的顶点，集合T中存放剩余顶点。初始转态
S只包含顶点v0，然后不断从集合T中选取到顶点V0路径最短的节点Vi并入集合S中，集合S中
每并入一个节点Vi都需要，需改顶点V0到集合T中顶点的最短路径（以Vi为中间节点进行扩展），
不断重复此过程，知道集合T都并入集合S中，和上面的普利姆算法对比，就会发现两个算法其实
理论上是一样的，都是选最短路径并入树中，只不过由于一个是有向图一个是无向图所以其实现
的过程存在差异，但是其理论一样。
##  弗洛伊德算法(任意两点之间)
通过集合S、T，集合S是任意两个顶点的最短路径矩阵，T记录当前两个顶点最短距离需要经过的
中间节点。从顶点0到顶点n，以顶点i为中间节点，如果通过中间节点的路径长度比之前的路径长度
短，则使用新的路径长度覆盖集合S中的已有长度，集合T中的中间节点改为新的节点，如果没有中间
节点则用-1表示，路径长度用最大值表示不存在最短路径，
## 使用场景
图主要使用场景，主要是在真实的生活中，比如交通、地图、旅行家问题都是对图的使用。最常见的
就是地图导航的
## 总结
图是比树更复杂的数据结构，由于图中存在回路和方向，所以其使用起来更复杂但是也可以解决更复杂
的现实问题，具体的话，其实我对这个图的使用，也是比较少的，主要了解的也是交通但是具体的使用
需要后续更新。