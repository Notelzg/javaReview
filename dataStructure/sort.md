# 排序
关键字：
排序的由来就是一直存在的，所谓人往高处走，水往低处流，排序这个事情其实一直
在我们身边，比如考试成绩排名，单科成绩排名，甚至古代科举考试都是一样的。
## 定义
在已有的无序或者有序的数据基础上，把新的数据插入到已有的数据序列中，并且使整个数据保持有序。
稳定性：如果两个以上相同的数据a b，在排序前和排序后都保持 a 在b前 或者b后，则该排序是稳定的。
##  插入类排序
思想，就是在一个已经有序的序列中，插入一个数据，并且保证插入后序列仍然序的，这就导致了这个有序
序列里面的元素的位置并不是自己最终的位置，除非不再插入数据，或者插入位置都在队列的末尾，这些都
属于特殊情况。
插入类排序的实现方式：直接插入排序、折半插入排序、希尔排序
### 直接插入排序
简单粗暴，默认第一个元素是有序的，因为只有一个元素所以肯定有序，把插入元素A和前一个元素 pre 做对比，如果
比它小，后移pre元素，直到找到一个比A元素大的pre元素，在pre元素后面插入元素A，完成一次插入排序。
### 折半插入排序
其思想一样，只是在数据量特别大的情况下，通过折半搜索的思想来找到插入位置，找到插入位置之后，则该位置之后的
数据都向后move一位，在该位置插入数据。
折半思想就不说了， mid = (left + right)/2
### 希尔排序
思想是把序列按照某种规则分成几个子系列，然后对子序列进行直接插入排序，然后依次减少子序列的个数，直到子序列的
个数为1，则排序结束。这个规则就是增量，用步长 5 3 1 切割序列，进行直接插入排序，步长必须是素数，大部分人都是
使用用序列的长度/2得到步长的，并不对步长进行验证，其实更好的方式☝应该是是由一个素数数组被提供出来使用，每次从
素数数组中取出步长。或者有一个素数计算算法获取。
步长gap 通常使用 len/2 
通过gap我们可以得到序列被分为多少组，组的大小其实就是gap，因为
组内成员下标起点是 = 0->gap, 增量就是gap，大小不超过len
## 交换类排序
交换类排序特点是，每一轮交换都会产生一个最大/最小值，被交换到最终的位置上去，然后下一轮交换的序列就会把这个位置
排除在交换序列中，知道交换序列长度为1，则整个序列有序。
### 冒泡排序
分为两层，外层循环控制序列的长度，内层循环进行交换，把最大/最小值交换到序列的末尾。假如序列本身是有序的则使用一个
标记，如果内层循环没有发生交换则退出排序。这是一种性能方面的优化。
### 快速排序
快排的思想是把序列的某一个值temp，放到正确的位置mid上去，只要保证temp左边的值都比temp小，右边的值都比temp大，这个temp
就是在最终的位置上了，然后把序列从mid位置，分成两个序列，两个序列在进行快快速排序，然后再两个的基础上，划分成4个子序列，
直到划分不出子序列为止，由于每一次的排序都会产生一个正确的位置，所以最终没有子序列则可以保证整个序列都是有序的，毕竟大家
都在自己的最终位置上，使用分治思想进行排序，需要用到递归，可以使用stack自己控制。
交换过程：默认规则是把序列最左的值，选做temp，然后从后向前对比找到比temp小的则放到左边空出来一个位置，然后从左向右对比
找到一个比tmp大的，则放到右边空出来的位置上，直到空出来的位置重合，则这个位置就是temp的终点。
## 选择类排序
思想就是选择，扫描整个序列找到最小值和第一个值进行交换，接着从剩下的序列中重复上述过程，直到序列长度为1，则结束。
### 简单选择排序
外层循环控制有序序列列的长度从1-n，内层循环控制无序序列长度找到最小值，然后进行交换。每循环一次，有序序列长度增加1
无序序列减1，有序序列从1-n，无序序列从n-1，有序序列从最左边开始，无序序列一直到最右边。
### 堆排序
通过把数据构造成大顶堆，或者小顶堆，获取最大值或者最小值，堆的定义是完全二叉树，但是要求其非叶子节点都不大于（不小于）
其左右孩子节点的值堆使用数组进行存储，因为叶子节点肯定满足不大于或者不小于左右孩子节点的值，所以只关注非叶子节点，由于
使用数组存储，所以这个堆肯定是一个完全二叉树的结构，根据完全二叉树的特点，数组的长度len/2 -- len 下标的都是叶子节点
从0- len/2 的都是非叶子节点，所以初次的堆，需要对每个非叶子节点进行调整，堆建好之后，因为每次只取出顶点元素和序列的末尾
元素进行交换，只会顶点是无序的需要调增。
堆的调整算法
如果存在右子树，并且比左子树大，则让指针指向右子树和父节点进行对，如果满足则退出，如果不满足则进行交换，交换之后可能导致
子树的子树不符合条件，所以这个交换需要进行到叶子节点。
## 二路归并排序
和希尔排序的思想一样，区别是二路归并排序的步长是从1开始，正好和希尔排序相反。
先把序列按照序列的长度len，分成len份，每一个份都是有序的，然后相邻的进行合并，由于每次都是相邻的两个元素进行合并所以被称为二路
归并排序。
算法：
首先对序列进行分组 len/2 向上取整，可以得到第一次的组数，比如7个元素，第一次合并是之后是4组序列，第二次是 4/2 是组，
最后一此是 一组，所以首先取出来组数这个groupCount概念。
分组之后组的长度，groupLen =  len / groupCount,序列长度除以组的总数，得到分组序列的长度，
4组序列的，第i组的开始下标是  groupLen * i ,由于序列长度可能是奇数，所以需要小于序列长度，
在第i组内，进行插入排序，选择排序，冒泡排序都可以，保证组内的有序就行。
## 基数排序
基数排序是多关键字排序，比如扑克牌的花色和数字，是就两个关键字，对扑克牌的排序就可以使用基数排序。对关键字进行排序
每次保证一个关键字是有序，最终得到的就是所有都是有序的。
比如扑克牌，先用数字进行排序，使用13个桶，从走到右依次是 1到13
按照1-13，把待排序序列依次进入相应的桶中，桶是一个队列，保证先进先出，所有序列进入桶之后，开始把数据收集，从桶1到桶13
这个序列肯定是有序的按照1-13，然后按照花色4个桶 ，哪个桶的顺序这个自己定义吧，反正从1-4 作为从大到小
把刚才收集的数据分别入桶，最后再收集数据，则得到的数据肯定是先是按照数字排序有序，数字相同的则按照花色是有序的。
## 外部排序
外部排序的概念是对外存中的数据进行排序，也可以说是对文件中的数据进行排序，因为文件太大，内存一次放不下，所以才不使用内部排序。
先把一部分数据放到内存中排序，得到一个有序的序列，然后再把一分部外存数据放到内存得到一个有序序列，最后得到n个有序序列
使用k路归并排序，最终得到有序序列，这其中需要用到树。
### 归并树排序
### 败者树
