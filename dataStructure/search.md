# 查找算法
查找这个词由来已久，比如找个地方吃饭，找个人，自古以来查找就是人类生活中的一部分，只不过我们这里的算法
是把生活中的查找，是以计算机语言的形式表现出来。
## 定义
给定一个值k，在含有n个记录的表中找出关键字等于k的记录，若找到则查找成功，返回该记录的信息或者该记录在
表中的位置。否则查找失败，返回相关的指示信息。
## ASL
ASL是查找算法的性能分析。
平均查找长度 ASL= Pi * Ci， i(0, n), n是查找表中记录的个数
Pi查找第i个记录的概率一般是 1/n，Ci找到第i个记录需要进行比较的次数
## 顺序查找法
就是从表的一端开始，扫描整个表，如果当前扫描的关键字等于k，则查找成功，若扫描结束后仍未发现关键字等于
k的记录，则查找失败。
## 折半查找法
折半查找法和折半插入是一样的原理，只是折半插入是利用折半查找法寻找插入点，折半查找/插入的前提是数据表是有序的
通过对比k和有序表的中间位置mid的关键字对比，如果相等则查找成功，如果小则和mid坐标的中间值继续对比，如果大则和
mid右边的中间值对比 ,大概思路如下
while(left < right){
    mid = (left + right)/2
} 
## 二叉排序树
二叉排序树就是根据排序树的特点，根节点大于左子树小于右子树，所以其原理和实现和折半查找一样，如果k和根节点
相等则查找成功，如果比根节点小则去左子树进行查找，否则去右子树进行查找。
```
if (k == p->data)
   return p
else if (k < p->data)
   return search(p->lchild, k);
else
   return search(p->rchild, k);

```
## 二叉平衡术
概念是左子树和右子树的高度差不能超过1，索引引申出了平衡因子的概念，平衡因子=绝对值（左子树高度-右子树高度）
### 插入操作，存在 LL LR RR RL 四种需要调整的情况。
对于LR 和 RL的情况，其最下面的节点肯定是处于三个节点中的中间值，所以把这个值作为父节点，其他的两个作为左右孩子
进行调整就行，由于LR 和 RL的结构保证了不会存在其他的情况，按照这个规则调整就没问题。
进行处理，对于LL和RR处于不平衡的最小树，肯定是中间的节点作为父节点，然后两个节点按照大小作为左右子树，但是LL和R
在调整的时候会存在，其他的节点需要调整的情况，就是在这三个节点上面还有其他节点，对于其他节点的处理，按照新插入节点
的方式，进行插入操作处理，因为重构之后，最初的三个节点组成了一个完全树，而中间节点作为根节点，其他两个节点作为左右子树
中间节点如果还有另外一个孩子节点则需要对这个节点进行插入操作处理，保证树的稳定。
### 删除操作
情况1 ： 如果是叶子节点直接删除，修改平衡因子，如果不平衡则进行调整，删除操作的调整和插入操作调整一样 LL RR LR RL,只是LR RL
存在和LL RR一样的问题，新的平衡树的根节点，之前的孩子节点需要重新插入树中。
情况2： 如果有一个子树，则把子树挂到,该节点之前的位置上。
情况3： 如果有两个子树，则需要沿着左子树的最右边的得到节点R，用R替换删除节点，同时R如果是叶子节点则按照情况1，如果有一个子树
则按照情况2处理。
其实我个人觉得，每删除一个节点，该节点的父节点都应该更新平衡因子,如果平衡因子不变，则整棵树还是平衡的，如果父节点的平衡
因子改变，并且是变为0，除非是根节点，否则由于子树高度的降低，肯定会导致更上层节点平衡因子的改变，所以需要继续向上更新直到
根节点， 如果平衡因子超过1，整棵树不平衡，需要进行调整。
## B-, B+ 树
n 是关键字个数，m是阶数
二叉树和二叉排序树，会导致树的高度太高，如果数据多，为了降低树的高度，重新定义了B树，其实也叫K路平衡术，只是由于使用
场景的不同分为B+ B-树。和二叉平衡树一样，B树不需要平衡因子，但是需要保证叶子节点在同一层，同时需要满足相应的条件。
B-树中有n个关键字的节点有 n+1 个分支， B+树中则是n个分支
B-树中节点关键字个数范围是   (m/2)向上取整 -1 =< n <= m-1, 根节点是   1 =<n <= m-1
B+树中节点关键字个数范围是   (m/2)向上取整  =< n <= m, 根节点是   1 =<n <= m
其插入和删除节点也和二叉平衡树一样，只不过不是用平衡因子，而是分支和关键字的关系
因为关键字个数在插入的时候已经满足了最小标准，所以删除的时候存在两种情况
关键字个数大于 m/2，和等于，如果大于则直接删除
等于m/2，则看其兄弟节点关键字个数如果大于m/2则可以借，如果等于则需要进行节点的合并。
插入操作就是如果大于m则进行根节点点的拆分，因为是拆分的根节点，所以插入操作只会导致树的高度变高，但是不会导致叶子节点
不在同一层。
B树的操作主要是由关键字和分支的关系来控制的，明确分支和关键字的关系，特别是B- B+树。
同时B+树的叶子节点存储数据，非叶子节点存储关键字便于搜索，所以一般的数据库设计都是使用B+树结构，保证快速的读写数据。
## 散列Hash表
散列表的特点就是查找快，时间复杂度O（1）
填装因子 a = n/m (n是关键字的个数，m为表长)
一般使用除留余数法得到hash值 H(key) = key % p,p是不大于表长的最大素数
散列Hash存在的问题就是，不同的key的会有相同hash值，这样就必须去解决冲突
问题，目前简单的有，开放定址法，链地址法。
散列最好的就是不冲突，让关键字均匀的分布在整个表中，可惜不现实，至少除余留数法是不可能做的的。
### 开放定址法
使用顺序表存储，对于冲突的处理最简单的方法，开放定址法，主要是如果在目标位置已经有关键字，则把当前关键字存储到下一个空闲
的位置，有可能后面也有值，所以需要一直向后找，直到发现空余位置，问题是容易造成关键字的堆积。
### 散列链地址法
使用顺序表+链表的形式存储，其实和图的链式存储结构一样，不信你去看看图的链式存储结构。就是对于每一个H(key)都用一个链表
来存储值，这样所有一样的hash值的关键字，会存在一个链表中，不会造成堆积问题，不过需要更多的存储空间。