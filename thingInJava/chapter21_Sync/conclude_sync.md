# 并发编程
并发可以说是计算机操作系统发展的的重要里程碑，随着分时复用理论的提出，计算机的发展从单一
任务处理器变成了多任务处理器（虚拟），随着多核cpu的出现，计算机在物理上也实现了多任务处理，但是
就像内存有多大程序就有多大意义，计算机的存在的目的就是为了提高运算速度，为了更进一步提升
进程速度，充分的利用计算机资源，线程作为一个轻量级的进程出现了，首先线程依赖于进程，和其他
线程共享进程的内存空间和资源，同时完成进程内部的任务，这就是线程的并发，多个进程同时运行的
叫做多任务，进程之间是相互独立的所以互不影响，线程共享进程的所有资源，所以通过并发提高运算
速度的同时，同时面临着对共享资源访问的同步问题，而并发编程主要解决的就是同步数据问题.
  JAVA通过Thread类定义了线程，通过实现Runnable接口，继承Thread就可以实现进程，当然内部
匿名方法，变量都是可以的.
## 多线程
多线程就是启动多个线程来完成任务。
## 同步机制
由于线层共享进程资源，所以面临共同资源的访问需要进行控制，不然就会出现数据的混乱，资源
的浪费等情况，所以需要同步机制进行对共享资源的同步访问机制。每个操作系统、编程语言对于进程的
同步都是不一样的实现方式，但是其理论肯定是一样的，比如都会有锁、互斥量、阻塞唤醒等，所以学习
同步的时候，可以顺便把理论复习一下。
### synchronize
java的同步关键字synchronize可以用来声明方法、类，如果声明方法使用了synchronize关键字则其实例化
的对象通过多线程调用该方法的时候回自动进行阻塞，而且方法里面的变量也会自动进行刷新，即使是在内存中
的变量，这个和volatile关键字提供的可见性有相同的特性，就是无论哪个线程修改了这个变量，其他的线程
都是可见的，读取的时候都是读取的最新的值，不会是之前的缓存的值，保证了数据的原子性和一致性。如果使用
synchronize关键字修饰static的方法，则方式就是一个类级别的同步方法了，所有调用该方法的类都最自动阻塞。
synchronize也可以用来修饰类，说明整个类是一个同步类，但是一般不会这样做，因为采用多线程的初衷是为了
提高运算速度，但是同步本身是需要开销的，是会降低运算速度的。所以synchronize是最简单也是最容易使用的
同步机制，但是如果想要进行性能调优，就要使用最适合的同步机制。
自动刷新内存中的数据
### lock
锁是一个很常见的字，而且大家的而生活中约离不开锁，出门要锁门，下班要锁电脑，开车要锁车，手机要锁屏不论做什么事情
好像都要和锁挂钩，仔细观察就会发现为什么会出现这样的情况呢，这些锁的最终目的就是保护自己的私有财产，现在
个人隐私也属于私有财产了，那么线程为了保护私有数据，因为每个线程都认为自己拥有全部的，所以线程可以使用锁
来保护自己的私有数据，这个私有数据指的是进程共享资源，通过对共享资源加锁和解锁实现数据的共享，完成自己的任务
不让别人的线程打扰自己的私活。使用锁的时候可以使用下面的范式
```
try{
   lock.tryLock();
}finally{
  lock.unLock();
}
```
### Atomic
数据库有一种事物，事物存在4个特别分别是 原子性、一致性、隔离性、持久性。通过事物可以保证一些job要么共同完成
要么就失败回退，去除了脏数据。Atomic就是原子性，是java同步机制的一个实现，使用Atomic可以进一步提供计算的速度
因为原子性 其本身的操作都是原子不操作，就不用担心同步的问题了，Atomic是一个分支，齐下有AtomicInteger 等具体的
原子类型，但是原子类有一点需要注意，虽然操作简单而且线程安全，原子操作只能针对数据较少且是原子类型本身支持的，目前
支持的只有基本数据类型。
### 互斥量
互斥量还有另外一个名字就是信号量，互斥量是信号量中的一种，互斥量同时只能有一个线程获取，其他获取的线程会阻塞，互斥量
适合对于临界区进行同步，简单的来说互斥量就像一个 boolean类型的变量，如果为true则可以进入临界区进行处理，处理完成之后
设置为false,唤醒其他线程继续进行处理。互斥量的前提是该变量必须是所有线程可见的，不能是缓存，所以必须使用volatile来修饰
该变量，同时对该变量的操作应该是原子性的，通常来说 boolean类型的赋值必须是一个原子性的操作，如果无法确实赋值操作是否
是原子性，或者线程安全，则必须使用synchronize关键字来声明赋值的方法，同时该变量☝应该被声明为private，保证只能通过
线程安全的方法给变量赋值，否则该互斥量保护的临界区将会被多个线程操作，导致程序出现不可预知的问题。红绿灯。
通过原子性和可见性实现
## 线程协作
线程之间可以进行协作完成一个任务，常见的有使用阻塞队列，保证同时只有一个线程处理共享资源，也有计数器 计数器清零之后
释放资源，也有栅栏等所有线程都执行到了一样的节点之后，进行处理。
通过阻塞实现
### wait notify
通过使用wait可以使当前线程阻塞，接收到notify通知之后被激活，然后继续操作，如果还是获取不到资源则继续阻塞，直到获取
相应的资源，这种阻塞都是长阻塞，获取不到资源就一直阻塞.
线程的声明周期
### 阻塞容器
下面是java提供的阻塞容器，通过把对象存入阻塞队列，实现对象操作的同步，因为get操作是阻塞的，同时只能有一个线程获取到
一个对象，不同的线程不能获取到同一个对象，所以是线程安全。
ArrayBlockingQueue
是通过数组来实现
LinkedBlockingQueue
linkerList是一个链表
CountDownLatch
计数器同步
CyclicBarrier
栅栏同步
DelayQueue
延迟队列
PriorityBlockingQueue
优先级队列
Semaphore
信号量
Exchanger
交换器
### 免锁容器
在进行写、读取操作的时候，不会阻塞写读取操作，因为使用的是写时赋值技术，修改数据的时候会把该数据复制出来进行处理，
处理完之后放回数据结构中，这个操作是原子性的是一个事物，解除了锁提高了效率。以下是java提供的容器。
CopyOnWriteArrayList
ConcurrentHashMap
ConcurrentLinkedQueue
### 乐观加锁
乐观锁比免锁容器更快一点，因为也不需要进行写时复制.
#### Atomic.compareAndSet
该操作是在修改前判断该值和上一次的值是否一样，如果一样则认为该值没
被修改，可以直接进行操作，如果不一样的，则重试一次，还不行就需要进行失败处理了，这里最麻烦的就是失败的处理。
#### ReadWriteLock
读写锁适合少修改和大量读取的情况，因为读不需要锁，只是在写的时候会阻塞保证数据的一致性，所以如果只有恨少的
修改操作则比较适合。
## 性能调优
不同的同步机制，其性能是不一样的，synchronize 正常来说是最稳定的也是最慢的，其次是lock，atomic 、互斥量、免锁容器
乐观锁相对来说是最快的，但是具体的情况是需要进行试验的计算，而且越快的同时需要保证数据的同步，所以在提高性能的同时
应该确保数据的一致性。
## 活动对象
