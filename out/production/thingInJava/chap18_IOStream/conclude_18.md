# I/O流
 java中对文件的操作主要是用使用流的概念来处理，就像自来水的流通一样
 通过源头，使用大管道运输，在接通家里的小管道，再给管道在各个地方安装
 上开关，就构成了整个的用水系统。java基于这个概念，封装了比较多的类
 针对不同的情况，但是这些类都是装饰类，底层的还是 File 面向字节的流
 面向字符的流，面向对象的流等。不同的流使用环境不一样，但是其都有
 read write方法，还有自己的特定方法，下面咱们会针对这些流，进行总结
 画出其类图，UML关系图，来理解其关系和分析其适合的使用场景。
 ## UML图
 ## File的操作
 File在java 是一个类，可以表示目录和文件，有一个File的 过滤器类用来
 和获取符合条件的文件，比如，文件大小、文件格式、文件修改、创建日期等
 这是一个接口，FileNameFilter 实现其accept方法，在该方法内部，进行
 判断，返回true 则该文件就返回，返回false则丢弃。FileNameFilte主要是
 针对文件名称来的，还有一个策略设计模式的来处理文件，比如文件大小
 格式、修改时间等，不过这是通过内置一个接口实现的，用户自己实现该接口
 就可以定制处理文件的过程，属于策略模式，从这里也可以学习一些策略模式
 的概念，通过定义接口，或者抽象类，使用策略，但是通过导出类实现，
 实现不同的定制化的策略。
 例子在ProcessFiles文件中。
## 缓存
为了加快速度，所以有了缓存技术，在I/O操作中，以buffer开头的都是用来做缓存的
比如： BufferReader 对应的字符缓冲，BufferInputStream 是面对字节的缓冲.
经过总结发现，java中对字节的操作都是以Stream结束，对于字符的操作是以Write/Reader结尾，
最起码针对的文件操作是这的的。
## 格式化数据
使用DataInputSteam, DataOutputStream，对数据进行格式化，比如writeDouble、writeUTF，
成对的使用 writeDouble readDouble，可以保证数据的准确性，无论在哪个平台上面,解决
不同平台的兼容性问题, 其缺点是必须知道要读取数据的位置和类型，不然在就会造成数据的混乱，这一点
就是需要通过结构性文件来处理，比如 xml yml、json等结构性文件。
## 支持文件内容搜索的文件类
 ### RandomAccessFile
 通过seek函数，到文件的任意位置，通过WriteDouble/UTF等函数，修改该位置的内容，而且
 这个类提供了搜索文件内容的功能，当然再jdk1.4之前，之后 由nio存储映射文件取代。
##  管道
PipeFileOutStream
PipeFileInStream
PipeReader
PipeWriter
管道主要用于进程间通信，使用场景是多线程。
## 重定向
System.setIn(PrintStream)
System.setOut(PrintStream)
System.setErr(PrintStream)
面向字节流
## ByteBuffer
字节缓冲区，通过字节缓冲区的视图，可以实现对同一格式的数据，进行不同格式的转换
比如 吧 int ，转成 其他所有的基本类型。这个是通过把缓冲区转成不同类型的视图来
完成的，同时对视图的操作，反过来可以影响缓冲区中的数据。
由于字符是由字节组成的，所以字节缓冲区☝应该是属于最底层的缓冲区，相对于物理设备
缓冲区，或者操作系统缓冲区。当然这个缓冲是建立在系统缓冲的基础上的。
缓冲区的基本操作
put 
get 
rewind
hasRemaining
position
视图转换
asFloatBuffer ，float可以使用其他基本类型替换，支持所有基本类|型的视图。
在进行视图转换是根据基本类型所占的字节长度来对缓冲区进行准换的,转换视图
本身不会对缓冲区数据有任何影响。
## 文件锁
|API | 锁类型 | 解释  |
|:---:|:----:|:-----|
|tryLock| 非阻塞 |  尝试给文件加锁，如果失败则返回null，不会阻塞当前进程|
|lock   | 阻塞锁 |  会阻塞当前进程，直到获取到该文件的锁。|

lock(postion, size, shared) ,部分文件加锁，以及是否共享，针对大文件，特别是
映射文件使用，比如数据库的操作，就是文件部分加锁实现的。
java 的文件锁，会调用操作系统的文件锁，所以可以在不同进程间使用，即使是非java进程。
## 文件压缩
java 支持Zip和gzip压缩，通过zip和gzipStream流来实现，经过该流的数据
都会自动进行压缩。
jar文件也是一种压缩文件，而且跨平台效果也不错。
## 对象序列号
对象序列化技术主要是为了解决，对象在程序(具体应该是进程 更具体的说应该是Java虚拟机进程中，并且被垃圾回收器回收前)
为了在其他进程中使用该对象，换句话说，在其他的空间或者时间使用该对象，需要使用序列化技术，把对象以及该对象引用的对象
都用对象流(ObjectInputStream,ObjectOutStream)进行处理，可以存入文件，在本地系统的其他时间使用，或者进行网络传输在其他操作系统运行，是一种兼容操作系统的
毕竟java虚拟机是跨操作系统的。
### 序列化定制化 Externalizable
通过implements Serializable接口可以使用基本的序列化方法简单易用。但是如果对序列化有特殊要求
比如子对象需要重新创建，或者某一部分不被序列化。
Externalizable 接口继承Serializable
### transient 
该关键字和 serializable  配合使用，serializable接口默认序列化所有数据，如果不想被序列化可以使用
transient 关键字来反序列化，比如用户密码。当然这个关键字也在注解里面被用来去除数据库持久层对象的反持久层，
意思是只在持久层使用，但是不存入数据库。
