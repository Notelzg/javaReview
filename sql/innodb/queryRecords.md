# 查询条记录

## 逻辑sql语句
```
1, select * from t  where nornal_key = 100;
2, select * from t  where uk=100;
3, select * from t  where a=100;
4, select * from t  where a>100;

```
### 锁范围分析
语句1-4，是不存在锁的，如果需要加锁可以通过 在语句后添加 for update （排他锁）， in share mode 共享锁。
但是不管家哪个锁，只要修改数据，会给修改的数据添加排他锁。加锁之后的锁定范围如下
语句1， 命中普通索引，锁定所有的索引，因为 nornal_key 是一个普通的索引，新增的key值可能在当前key值的前面或者后面，所以
为了防止出现幻读所以要给整个索引加锁；
语句2，命中唯一索引，且使用的等号，所以该记录只会存在一条，所以只要锁定一个记录就可以了。
语句3，命中主键索引,主键索引是唯一性的，且使用的等号，所以该记录只会存在一条，所以只要锁定一个记录就可以了。
语句4， 命中主键索引，但是 > 100是一个范围，所以会使用 next locking 锁定 大于100的索引。
### 隔离性 
就算上面查询的数据已经被加了X锁，但是通过MVCC机制，还是可以读到数据的，不会被锁住。
REPEATABLE READ 隔离级别下, MVCC机制是读取第一次读取的记录，所以其事务范围内读到的数据结果是不变的。
Cead Commit隔离级别下，由于MVCC机制是读取罪行的事务结果，所以其事务范围内，多次读取的记录数据可能不一样，因为如果有事务岗提交，是会拿到事务提交的的数据；
## 物理
### ibddata1
读取B+数，根据命中的索引，读取不同的索引文件，找到主键索引。
### t.bid
通过主键索引锁定一个数据页，加载到内存中，因为操作系统搜是页加载模式，所以该记录相近的记录也会被加载到内存中。
通过数据页的根据主键值构造的有序的数组，通过二分查找找到数据的记录
然后通过双向链表找到真实数据记录;
### undolog
通过undolog，实现mvcc，我理解应该是会记录第一次读到记录的事务id，下一次读取的时候读取同一个事务id的
数据，从而保证了多次读取数据的一致性。
### queryLog
#### slow querylog
慢查询日志，mysql通过配置 
```
show VARIABLES like 'log_slow_admin_statements'
# 默认值OFF，是关闭的，需要手动打开

show VARIABLES like 'long_query_time'
# 默认是10s，超过10s的查询sql(等于10s不会记录），挥别记录到慢查询日志文件中，
```
#### not user index log

```
show VARIABLES like 'log_queries_not_using_indexes'
# 默认关闭
```
可以使用 mysqldumpslow a.slow.log 
分析慢查询日志，

## 总结
查询目前主要是使用mvcc机制避免锁带来的开销，通过索引机制加快查询的速度，合适的
索引是可以加快查询的效率的，通过目前mysql也有对索引进行优化的技术，Multi-Range Read(MRR)
Index Condition Pushdown (ICP) 但是这些都是建立在命中索引，同时是范围查询的基础上的
除非逼不得已，我们应该都是对单条记录进行处理，或者存在记录挨着的进行处理，最好的情况是不去使用
这些优化技术肯定是更快的，如果确实有范围查询的，那就需要知道有这些优化技术，可以极大的提升效率。

