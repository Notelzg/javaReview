# 数据库的锁
mysql 数据库的锁用来保证数据库的隔离性。
主要分为表锁和行锁。
意向锁，以及锁
## 表锁 
表锁主要是意向锁，IX 和 IS，主要的目前是告诉其他进程，未来该表会发生的事情。
IX IS 是互相兼容的，其目的是，在进行加锁的时候，可以知道目前已有的锁，正常情况下
想要知道一个表有没有锁是需要遍历所有的记录从而知道的，使用意向锁可以把时间复杂度
从 O(N)降低到 O(1), 提高效率。
IX
## 行锁
S 共享锁， X 排他锁，其实即使读写锁的，读锁，和 写锁。
排除他锁用法： select * from t for update
共享锁用法； select  * from t  LOCK in SHARE MODE
## 通过实际操作，查看锁的范围、类型
```
tranaction T1
1,1 BEGIN
2, UPDATE t set nornal_key=1000;
3, commit

```
首先执行T1. 第一步 和第二步
执行查询数据库目前存在的事务以及锁
```
# 查看事务
select * from information_schema.INNODB_TRX;
# 查询锁
SELECT * from `performance_schema`.data_locks;
```
可以看到table t被加上了, 通过表，data_locks.LOCK_TYPE 字段查看是 IX锁 
其他的数据库记录通主键添加的 X锁，
除了以上的信息，为了防止幻读的存在，还会添加一个范围锁，也就是大家说的 next key 锁，由于没有使用where语句
添加范围，所以这里会加一个范围锁，锁定整个表,通过LOCK DATE ，查看其类型是： supremum pseudo-record
所以建议大家使用的时候是在有主键索引，或者唯一索引上面使用，因为其唯一性锁定的只是一个记录，当然要where语句命中
唯一索引才行，如果是其他索引还是会加上 net key锁，导致数据表被锁定，如果这个时候有大量的写请求会导致整个数据库的
locd变高，有可能拖垮整个数据库。
## 提示
不管是有没有显示的开启事务，有没有显示的加锁，只要是会修改数据记录的语句，数据库执行的时候会自动添加事务
自动加锁。

## 总结
通过一个简单的demo，我们可以把看到mysql的加锁机制，通过查看INNODB_TRX, data_locks 这两个表 我们也可以分析
要执行语句会造成的影响，所以如果遇到不确定的语句，应该现在测试环境通过执行语句， 就可以分析是否能达到自己想要的
效果，或者出现了，线上问题，也可以通过这两个表，知道是不是发生了锁，哪些数据被锁住了。
