#删除一条语句

## 逻辑sql语句
```
delete from  t SELECT whre a= 100;
```
### 逻辑上记录
删除记录
### 隔离性 
删除的记录在 REPEATABLE READ 隔离级别下是继续可以看到的
但是在 read Commit隔离级别下，是不可以看到的。
### 数据库锁
只要是对表记录的修改，会自动一个添加一个事务，即使不显示的声明，mysql 也会给你加上一个事务
所以insert 语句自动加锁, 如果这个时候有人执行了 select for update 操作，或者修改操作导致
范围加锁则会导致 update 语句插入等待，默认10s内获取不到锁则抛出异常。
## 物理
### double write
数据缓存先进入double weite，再写入相应的数据页
### ibddata1
删除相应的所有索引，主键素银、唯一索引、辅助索引，由于是B+树结构，删除索引的操作还是
比较重的，特别是涉及到合并索引、拆分索引节点的话。
### t.bid
在双向链表中，找到具体的数据，然后deleteFlag标记为1，等待专门的进程去最终删除数据，并且把
节点挂到freeList上面，进行复用。所以大量删除也有可能是造成内存碎片化的一个原因。
### redolog
重做日志包含，删除的数据记录、插入的索引
### undolog
对应的反向操作 ,插入语句
```
insert into t SELECT 100,100,100,100;
```
重做日志 
### binlog
就是insert 语句，这里就不再列出了，太长了，大家可以使用 
mysqlbinlog -vv binlog.000004 语句去观察，但是需要注意的是 binglog
有三种不同的记录方式，statement、row、mixed,其内容是不一样的。
## 总结
删除很简单，但是有的时候回变成新能杀手。
