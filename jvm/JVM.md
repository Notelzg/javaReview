# 深入理解java虚拟机总结
## jvm内存模型
jvm整个内存区域分为公共区域和私有区域，公共区域属于进程，私有区域属于线程，可以这样理解。
公共区域: 堆(成员变量)、方法区(类变量，方法)
私有区域：虚拟机栈、本地方法栈、程序计数器
运行时：
进程使用主内存（main memory/堆), 线程使用本地内存(local memory/线程区域)
主内存和本地内存通过同步机制把本地内存的数据更新到主内存，其他线程通过从主内存取出更新到本地
内存实现数据在不同线程之间的同步。
## 从java到对象
1          2        3           4        5                         6           7
java---> class---> load----> check---> ready --> analysis ---> inner initialization
1, javac 编译从java文件到 字节码文件（class)
2, 把字节码文件加载到内存中生成一个 class对象可以被访问的
3，对class对象进行 
文件格式验证： jdk版本、常量池, 魔法字符
元数据验证: 非abstract声明的是否实现了所有实现，是否多继承.
字节码验证：执行流程的验证比如控制流程，数组是否越界。
符号引用验证: 对象引用是否有权限。
4, ready
给类变量分配内存空间(不进行初始化)，但是对于final类型的变量在这里直接执行内存数据的初始化
5, analysis
分析字段、方法、类的常量引用，从UTF8字符串替换为在内存中的引用也就是所谓的在jvm中的内存地址。
6， initialization
成员的初始化，在这里首先进行类变量的初始化，会搜集所有的static生命的变量、方法然后执行，但是
这里有个前提是会首先执行父类里面的，因为load加载的时候会首先加载父类class，所以父类初始化
也是在子类之前进行。
## jvm垃圾回收机制
标记清理
产生碎片，慢
cms
复制
需要更多的空间
标记整理
需要停顿 stw，然后进行一端的移动，保证空间的连续性
分代
edon survivor old metaspace
新生代，生存代，老年代，永久代
分块
G1 把整个内存区域按照块进行分割，然后使用复制算法清理
## java为何比c慢
字节码解释器 本地变量栈  操作符栈
因为jvm使用字节码执行引擎，解析字节码流，同时使用本地变量表栈和操作符栈进行jvm指令的执行。
不是一条条指令执行而是通过 变量表栈和操作符栈，这一步时jvm比exe程序多出来的操作，所以导致速度变慢，特别
是最初内存 cpu资源特别小的时候，但是随着cpu 内存 寄存器等计算资源的不断增长和java 虚拟机对native的增强
就是对于经常运行的代码段会生成和c++一样的指令集去运行，其运行速度也会越来越快，特别是服务器程序，而且随着
大数据时代的到来，这多出来的一步会让java成为一个更牛逼的语言。
## loadClass vs Calss.forName
loadClass只是完成了加载 验证 准备 分析 但是没有进行初始化，会在第一次使用的时候继续初始化属于懒初始化。
forname是在完成所有的步骤，包括初始化.
## 同步问题
把锁换成乐观锁或则和使用CAS来增加效率。
不变对象是不会产生同步问题的
可变对象才会产生同步问题。
## 分发
静态分发
动态分发
